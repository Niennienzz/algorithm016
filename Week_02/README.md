学习笔记

## 再次加强切题四件套

- Clarification.
- Possible Solutions -> Optimal (Time & Space).
- Coding.
- Testing.

## 哈希, 映射, 集合

- 严格来说, Map, Set 等等之类的数据结构都是一套接口, 底层的实现可以不一样.
  - 以 Set 为例: HashSet, TreeSet, ConcurrentSkipListSet 等等.
- 哈希函数一般不用自己实现, 但它是哈希数据结构的灵魂, 原理要清楚.
- HashMap 除了无序之外, 是非常平衡和完美的数据结构, **查询添加删除均为 O(1)**.
- 解决 Hash 冲突:
  - 拉链法: 一个桶拉出一个链表, 极端情况查询退化到 O(N).
  - 开放地址法: 
    - 当关键字的哈希地址 p=H(key) 出现冲突时, 以 p 为基础产生另一个哈希地址 p1.
    - 如果 p1 仍然冲突, 再以 p 为基础产生另一个哈希地址p2.
    - 直到找出一个不冲突的哈希地址pi, 将相应元素存入其中.

## 树, 二叉树, 二叉搜索树

### 树

- 如何把一维的数据结构 (数据, 链表) 变得更快?
  - 空间换时间: 提前储存更多的信息, 例如跳表.
  - 升维: 一维结构变二维, 例如树/图.
- 树可以理解为没有环的特殊的图, 链表可以理解为没有分叉的特殊的树.
- 生活中的很多情形都可以以树来模拟, 例如棋类游戏, 例如人生...
- 树的遍历:
  - 深度优先遍历 (DFS):
    - 所有的节点走一遍. 一维结构循环即可. 树状结构循环不方便, 所以要拥抱递归.
    - 前序 Pre-Order: **根** -> 左 -> 右. (节点顺序可交换, 根必须在前)
    - 中序 In-Order: 左 -> **根** -> 右. (节点顺序可交换, 根必须在中)
    - 后序 Post-Order: 左 -> 右 -> **根**. (节点顺序可交换, 根必须在后)
    - 如果一定不能用递归, 则可以用一个 Stack 来模拟递归压栈.
  - 广度优先遍历 (BFS):
    - 和深度优先遍历不同, 广度优先遍历会先访问离根节点最近的节点.
    - 二叉树的广度优先遍历又称按层次遍历, 算法借助队列 (Queue) 实现.
    - 此时需要注意, 广度优先遍历并不是递归算法.
  - 小结: 深度有三种, 可用递归或栈实现. 广度可用队列实现. **遍历为 O(N), 因为每个节点都要访问**.

### 二叉搜索树 (Binary Search Tree)

- BST 是一颗空树或者具有下列性质的二叉树:
  - 左子树上**所有节点**的值均**小于**它的根节点的值.
  - 右子树上**所有节点**的值均**大于**于它的根节点的值.
  - 以此类推, 左/右子树也分别为一颗 BST, 具有重复性.
  - 因此易得, BST 的中序遍历为升序排列.
  - **查询插入均为 O(logN)**.
  - 删除: 叶子直接删除, 若为根节点或子树根节点, 则取**最接近**此根节点的节点来代替.
    - 注意, **最接近**是指取值, 而不是节点的相对位置.
    - 一般取最邻近的, 大于原根节点的值, 也就是原根节点右子树里最小的节点.
    - 综上, 删除实际上也要进行查找, 以及常数次的节点调整, 因此**删除为 O(logN)**.
  - 极端情况下 BST 在没有平衡操作的帮助下会退化成单链表.
