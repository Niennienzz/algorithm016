学习笔记

## 再次加强切题四件套

- Clarification.
- Possible Solutions -> Optimal (Time & Space).
- Coding.
- Testing.

## 哈希 / 映射 / 集合

- 严格来说, Map, Set 等等之类的数据结构都是一套接口, 底层的实现可以不一样.
  - 以 Set 为例: HashSet, TreeSet, ConcurrentSkipListSet 等等.
- 哈希函数一般不用自己实现, 但它是哈希数据结构的灵魂, 原理要清楚.
- HashMap 除了无序之外, 是非常平衡和完美的数据结构, **查询添加删除均为 O(1)**.
- 解决 Hash 冲突:
  - 拉链法: 一个桶拉出一个链表, 极端情况查询退化到 O(N).
  - 开放地址法: 
    - 当关键字的哈希地址 p=H(key) 出现冲突时, 以 p 为基础产生另一个哈希地址 p1.
    - 如果 p1 仍然冲突, 再以 p 为基础产生另一个哈希地址p2.
    - 直到找出一个不冲突的哈希地址pi, 将相应元素存入其中.

## 树 / 二叉树 / 二叉搜索树

### 树

- 如何把一维的数据结构 (数据, 链表) 变得更快?
  - 空间换时间: 提前储存更多的信息, 例如跳表.
  - 升维: 一维结构变二维, 例如树/图.
- 树可以理解为没有环的特殊的图, 链表可以理解为没有分叉的特殊的树.
- 生活中的很多情形都可以以树来模拟, 例如棋类游戏, 例如人生...
- 树的遍历:
  - 深度优先遍历 (DFS):
    - 所有的节点走一遍. 一维结构循环即可. 树状结构循环不方便, 所以要拥抱递归.
    - 前序 Pre-Order: **根** -> 左 -> 右. (节点顺序可交换, 根必须在前)
    - 中序 In-Order: 左 -> **根** -> 右. (节点顺序可交换, 根必须在中)
    - 后序 Post-Order: 左 -> 右 -> **根**. (节点顺序可交换, 根必须在后)
    - 如果一定不能用递归, 则可以用一个 Stack 来模拟递归压栈.
  - 广度优先遍历 (BFS):
    - 和深度优先遍历不同, 广度优先遍历会先访问离根节点最近的节点.
    - 二叉树的广度优先遍历又称按层次遍历, 算法借助队列 (Queue) 实现.
    - 此时需要注意, 广度优先遍历并不是递归算法.
  - 小结: 深度有三种, 可用递归或栈实现. 广度可用队列实现. **遍历为 O(N), 因为每个节点都要访问**.

### 二叉搜索树 (Binary Search Tree)

- BST 是一颗空树或者具有下列性质的二叉树:
  - 左子树上**所有节点**的值均**小于**它的根节点的值.
  - 右子树上**所有节点**的值均**大于**于它的根节点的值.
  - 以此类推, 左/右子树也分别为一颗 BST, 具有重复性.
  - 因此易得, BST 的中序遍历为升序排列.
  - **查询插入均为 O(logN)**.
  - 删除: 叶子直接删除, 若为根节点或子树根节点, 则取**最接近**此根节点的节点来代替.
    - 注意, **最接近**是指取值, 而不是节点的相对位置.
    - 一般取最邻近的, 大于原根节点的值, 也就是原根节点右子树里最小的节点.
    - 综上, 删除实际上也要进行查找, 以及常数次的节点调整, 因此**删除为 O(logN)**.
  - 极端情况下 BST 在没有平衡操作的帮助下会退化成单链表.

## 堆 / 二叉堆

### 堆

- 可以迅速找到一堆数中的最大**或者**最小值.
- 堆也是一个抽象数据结构: 一套接口, 底层的实现可以不一样.
- 常见实现有: 二叉堆, 斐波那契堆.
- 斐波那契堆需要了解, 一般不需要实现. 工业级的堆实现一般是严格斐波那契堆.
- 假设是一个大顶堆:
  - FindMax: O(1).
  - DeleteMax: O(logN).
  - Insert/Create: O(logN) or O(1).
  
### 二叉堆

- 二叉堆的实现相对容易, 性能在堆的其他实现中算及格, 但不算快.
- 通过完全二叉树来实现, 注意不是二叉搜索树. (二叉搜索树无法满足 FindMax/FindMin 的速度要求)
- 下面的例子均假设为**大顶堆**:
  - 是一个**完全树**.
  - 树中的任意节点的值总是大于等于其子节点的值, 所以 FindMax 可以直接返回根节点的值, O(1).
- 实现细节:
  - 因为是完全二叉树, 则可以通过一个数组来实现.
  - 假设第一个元素在数组中的索引为0, 则父节点和子节点的关系如下:
    - 索引为 i 的**左节点**的索引是 (2*i+1).
    - 索引为 i 的**右节点**的索引是 (2*i+2).
    - 索引为 i 的**父节点**的索引是 floor((i-1)/2).

```
           110
          /   \
       100     90
       / \     | \
     40   80   20 60
    / |   | \
  10 30   50 70

Array RepresentatioN: [110, 100, 90, 40, 80, 20, 60, 10, 30, 50, 70]
```

- 插入操作:
  - 新元素一律先插入到堆的尾部, 此时新元素是某一个父节点的叶子.
  - 依次向上调整整个堆的结构, 一直到堆顶即可. (HeapifyUp)
  - Worst-Case: 
    - 如果新元素比堆顶还大, 它需要向上浮动至堆顶.
    - 最大时间复杂度则为树的深度: O(logN).
  - Best-Case:
    - 如果新元素本就比插入时当前的父节点小, 它完全不需要向上浮动.
    - 最小时间复杂度则为: O(1).

- 删除堆顶操作:
  - 将堆尾元素替换到顶部, 堆顶被替代删除掉. (用尾元素可以保持完全二叉树的形态.)
  - 依次从堆顶向下调整整个堆的结构, 一直到堆尾即可. (HeapifyDown)
  - 从堆顶开始, 依次用当前的父节点和两个子节点的值比较, 父节点与较大的子节点交换.
  - 时间复杂度为树的深度: O(logN), 因为尾元素总是很小, 放到堆顶之后, 最后又会被调整至尾部附近.
  - 之所以用尾元素替代堆顶, 是因为明知道它会被向下调整, 但是可以保持树其他地方的完全性以及已有的顺序, 实际操作次数最小, 逻辑简单.

## 图

### 定义

- Graph(Vertx, Edge)
- Vertx: 点
  - 度: 入度和出度.
  - 点与点之间: 连通与否.
- Edge: 边
  - 有向与无向.
  - 权重 (边长).

### 表示方法 / 分类

- Adjacency Matrix, Adjacency List.
- 有向有权
- 有向无权
- 无向有权
- 无向无权

### More on Graphs

- [连通图个数](https://leetcode-cn.com/problems/number-of-islands/)
- [拓扑排序 Topological Sorting](https://zhuanlan.zhihu.com/p/34871092)
- [最短路径 Dijkstra](https://www.bilibili.com/video/av25829980?from=search&seid=13391343514095937158)
- [最小生成树 Minimum Spanning Tree](https://www.bilibili.com/video/av84820276?from=search&seid=17476598104352152051)
